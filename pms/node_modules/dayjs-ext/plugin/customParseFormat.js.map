{"version":3,"file":"customParseFormat.js","sources":["../src/plugin/customParseFormat/parseFormattedInput.js","../src/plugin/customParseFormat/index.js"],"sourcesContent":["/* eslint-disable prefer-arrow-callback */\n\nconst formattingTokens = /(\\[[^[]*\\])|([-:/.()\\s]+)|(A|a|YYYY|YY?|MM?|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g\n\nconst match1 = /\\d/ // 0 - 9\nconst match2 = /\\d\\d/ // 00 - 99\nconst match3 = /\\d{3}/ // 000 - 999\nconst match4 = /\\d{4}/ // 0000 - 9999\nconst match1to2 = /\\d\\d?/ // 0 - 99\nconst matchUpperCaseAMPM = /[AP]M/\nconst matchLowerCaseAMPM = /[ap]m/\nconst matchSigned = /[+-]?\\d+/ // -inf - inf\nconst matchOffset = /[+-]\\d\\d:?\\d\\d/ // +00:00 -00:00 +0000 or -0000\nconst matchAbbreviation = /[A-Z]{3,4}/ // CET\n\nconst parseTokenExpressions = {}\nconst parseTokenFunctions = {}\nconst parsers = {}\n\nconst daysInMonths = [\n  31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n]\n\nfunction isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\n}\n\nfunction checkDay(time) {\n  const { day, month } = time\n  let days\n  if (month === 2) {\n    days = isLeapYear(time.year) ? 29 : 28\n  } else {\n    days = daysInMonths[month - 1]\n  }\n  if (!(day >= 1 && day <= days)) {\n    throw new Error(`Invalid day: \"${day}\".`)\n  }\n}\n\nfunction correctHours(time) {\n  const { afternoon } = time\n  if (afternoon !== undefined) {\n    const { hours } = time\n    if (afternoon) {\n      if (hours < 12) {\n        time.hours += 12\n      }\n    } else if (hours === 12) {\n      time.hours = 0\n    }\n    delete time.afternoon\n  }\n}\n\nfunction makeParser(format) {\n  const array = format.match(formattingTokens)\n  if (!array) {\n    throw new Error(`Invalid format: \"${format}\".`)\n  }\n  const { length } = array\n  for (let i = 0; i < length; i += 1) {\n    const token = array[i]\n    const regex = parseTokenExpressions[token]\n    const parser = parseTokenFunctions[token]\n    if (parser) {\n      array[i] = { regex, parser }\n    } else {\n      array[i] = token.replace(/^\\[|\\]$/g, '')\n    }\n  }\n  return function (input) {\n    const time = {}\n    for (let i = 0, start = 0; i < length; i += 1) {\n      const token = array[i]\n      if (typeof token === 'string') {\n        if (input.indexOf(token, start) !== start) {\n          const part = input.substr(start, token.length)\n          throw new Error(`Expected \"${token}\" at character ${start}, found \"${part}\".`)\n        }\n        start += token.length\n      } else {\n        const { regex, parser } = token\n        const part = input.substr(start)\n        const match = regex.exec(part)\n        if (!match || match.index !== 0) {\n          throw new Error(`Matching \"${regex}\" at character ${start} failed with \"${part}\".`)\n        }\n        const value = match[0]\n        parser.call(time, value)\n        start += value.length\n      }\n    }\n    checkDay(time)\n    correctHours(time)\n    return time\n  }\n}\n\nfunction addExpressionToken(token, regex) {\n  parseTokenExpressions[token] = regex\n}\n\nfunction addParseToken(tokens, property, check) {\n  if (typeof tokens === 'string') {\n    tokens = [tokens]\n  }\n  let callback\n  if (typeof property === 'string') {\n    if (check) {\n      callback = function (input) {\n        const value = +input\n        if (!check(value)) {\n          throw new Error(`Invalid ${property}: \"${input}\".`)\n        }\n        this[property] = value\n      }\n    } else {\n      callback = function (input) {\n        this[property] = +input\n      }\n    }\n  } else {\n    callback = property\n  }\n  for (let i = 0, { length } = tokens; i < length; i += 1) {\n    parseTokenFunctions[tokens[i]] = callback\n  }\n}\n\nfunction offsetFromString(string) {\n  const parts = string.match(/([+-]|\\d\\d)/g)\n  const minutes = +(parts[1] * 60) + +parts[2]\n  const offset = minutes === 0 ? 0 : parts[0] === '+' ? -minutes : minutes // eslint-disable-line no-nested-ternary\n  if (!(offset % 15 === 0 && Math.abs(offset) <= 765)) { // 00:00 - 12:45\n    throw new Error(`Invalid time zone offset: \"${string}\".`)\n  }\n  return offset\n}\n\naddExpressionToken('A', matchUpperCaseAMPM)\naddParseToken(['A'], function (input) {\n  this.afternoon = input === 'PM'\n})\naddExpressionToken('a', matchLowerCaseAMPM)\naddParseToken(['a'], function (input) {\n  this.afternoon = input === 'pm'\n})\n\naddExpressionToken('S', match1)\naddExpressionToken('SS', match2)\naddExpressionToken('SSS', match3)\nfor (let token = 'S', factor = 100; factor >= 1; token += 'S', factor /= 10) {\n  addParseToken(token, function (input) {\n    this.milliseconds = +input * factor\n  })\n}\n\naddExpressionToken('s', match1to2)\naddExpressionToken('ss', match2)\naddParseToken(['s', 'ss'], 'seconds', function (seconds) {\n  return seconds <= 59\n})\n\naddExpressionToken('m', match1to2)\naddExpressionToken('mm', match2)\naddParseToken(['m', 'mm'], 'minutes', function (minutes) {\n  return minutes <= 59\n})\n\naddExpressionToken('H', match1to2)\naddExpressionToken('h', match1to2)\naddExpressionToken('HH', match2)\naddExpressionToken('hh', match2)\naddParseToken(['H', 'HH'], 'hours', function (hours) {\n  return hours <= 23\n})\naddParseToken(['h', 'hh'], 'hours', function (hours) {\n  return hours >= 1 && hours <= 12\n})\n\naddExpressionToken('D', match1to2)\naddExpressionToken('DD', match2)\naddParseToken(['D', 'DD'], 'day')\n\naddExpressionToken('M', match1to2)\naddExpressionToken('MM', match2)\naddParseToken(['M', 'MM'], 'month', function (month) {\n  return month >= 1 && month <= 12\n})\n\naddExpressionToken('Y', matchSigned)\naddExpressionToken('YY', match2)\naddExpressionToken('YYYY', match4)\naddParseToken(['Y', 'YYYY'], 'year')\naddParseToken('YY', function (input) {\n  input = +input\n  this.year = input + (input > 68 ? 1900 : 2000)\n})\n\naddExpressionToken('z', matchAbbreviation)\naddParseToken('z', function (input) {\n  // istanbul ignore next\n  const zone = this.zone || (this.zone = {})\n  zone.abbreviation = input\n})\n\naddExpressionToken('Z', matchOffset)\naddExpressionToken('ZZ', matchOffset)\naddParseToken(['Z', 'ZZ'], function (input) {\n  const zone = this.zone || (this.zone = {})\n  zone.offset = offsetFromString(input)\n})\n\nfunction parseFormattedInput(input, format) {\n  let parser = parsers[format]\n  if (!parser) {\n    parser = makeParser(format)\n    parsers[format] = parser\n  }\n  return parser(input)\n}\n\nexport default parseFormattedInput\n","import parseFormattedInput from './parseFormattedInput'\nimport Utils from '../../utils'\n\nUtils.parseFormattedInput = parseFormattedInput\n\nexport default (o, C) => {\n  const proto = C.prototype\n  const oldParse = proto.parse\n  proto.parse = function (cfg) {\n    const { date: input, format } = cfg\n    if (format) {\n      try {\n        const {\n          year, month, day, hours, minutes, seconds, milliseconds, zone\n        } = parseFormattedInput(input, format)\n        let date\n        if (zone) {\n          const timestamp = Date.UTC(\n            year, month - 1, day,\n            hours || 0, minutes || 0, seconds || 0, milliseconds || 0\n          ) + (zone.offset * 60 * 1000)\n          date = new Date(timestamp)\n        } else {\n          date = new Date(\n            year, month - 1, day,\n            hours || 0, minutes || 0, seconds || 0, milliseconds || 0\n          )\n        }\n        this.$d = date\n      } catch (error) {\n        this.$d = new Date(Number.NaN)\n      }\n      this.init(cfg)\n    } else {\n      oldParse.call(this, cfg)\n    }\n  }\n}\n"],"names":["formattingTokens","match2","match1to2","matchOffset","parseTokenExpressions","parseTokenFunctions","parsers","daysInMonths","makeParser","format","array","match","Error","length","i","token","regex","parser","replace","input","time","start","indexOf","part","substr","exec","index","value","call","days","year","day","month","checkDay","afternoon","undefined","hours","correctHours","addExpressionToken","addParseToken","tokens","property","check","callback","factor","milliseconds","seconds","minutes","this","zone","abbreviation","offset","string","parts","Math","abs","offsetFromString","o","C","proto","prototype","oldParse","parse","cfg","date","timestamp","Date","UTC","$d","error","Number","NaN","init"],"mappings":"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"}